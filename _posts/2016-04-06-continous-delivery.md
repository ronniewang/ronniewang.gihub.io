---
layout: default
title: 持续交付
category: tech
description: 用全面的自动化解决软件交付中出现的问题
---

# 1. 第一章 软件交付的问题

## 1.1. 引言

本书的核心模式是`部署流水线`，以`持续集成`理论作为其理论基石

部署流水线有三个目标

* 让软件构建，部署，测试和发布过程对所有人可见，促进合作
* 改善反馈，能在整个过程中更早的发现和解决问题（做一件事，有问题发生是一定的，重要的是快速的定位和解决问题）
* 使在任何环境下部署和发布任意版本的应用成为自动化的过程，提高效率

一个简单的简单的`部署流水线`

提交阶段 ==> 自动化验收测试 ==> 自动化容量测试 ==> 手工测试 ==> 发布

## 1.2. 一些常见的反模式

### 1.2.1. 反模式：手工部署软件

这个反模式一般具有如下特征

* 有一份详尽的操作文档，其中描述了多出需要注意的地反
* 手工测试程序是否运行正确
* 总有客户来问，部署怎么又出问题了
* 如果是集群环境，个环境配置经常有出入
* 发布过程时间较长
* 发布结果无法预测（凭运气）
* 经常加班，还搞不定问题

理想的部署流程应该是

1. 挑选要部署的版本和环境
2. 按一下“部署”按钮

为什么需要部署自动化

* 使部署过程可重复
* 免去部署文档的维护，一个部署脚本即是所有文档
* 部署过程可审计追踪
* 摆脱对人的过分依赖

### 1.2.2. 反模式：开发完成之后才向生产环境部署

经常出现的情况

* 运维人员之前一直没有接触过应用程序
* 程序相关的配置，数据库脚本，部署文档等都没有在正式环境下测试过
* 开发团队和运维团队协作太少

导致的各种问题

* 第一次部署成了噩梦
* 开发环境和部署环境差距越大，问题越多
* 各团队之间协作焦头烂额

解决方案

将测试，部署和发布活动都纳入到开发过程中，让他们成为正常开发流程的一部分，对部署过程也进行测试

### 1.2.3. 反模式：生产环境的手工配置

这种反模式经常有如下特征

* 诶，我本地好使啊
* 集群中各节点表现不同
* 每次准备环境事件长
* 无法回滚
* 不知不觉，集群中的服务器，操作系统配置变得都不一样了

怎样解决这些问题？

采用配置管理，可以重复的创建开发应用程序所需要的每个基础设施

对于各个环境中的信息，都应该完全掌控，而且，所有环境的生成，配置的修改都应该由自动化程序实现，禁止手动修改

### 1.2.4. 如何改变这种情况

采用部署流水线，将软件的发布变成一种低风险、频繁、廉价、迅速且可预见的过程

最后的目标是实现将自动化的测试和部署，以及全面的配置管理结合在一起，实现一键式软件发布

## 1.3. 如何实现目标

为保证能持续的以高质量交付我们的软件，需要**频繁的自动化发布软件**

对于频繁的自动化发布软件，**反馈**是至关重要的，对于反馈，应该达到三个标准

* 无论什么样的修改都应该触发反馈流程
* 反馈应该尽快发出
* 交付团队必须接收反馈，并依据它做出行动响应

下面详细介绍一下这三个标准

### 1.3.1. 无论什么样的修改都应该触发反馈流程

这些修改包括对以下项的修改

1. 源代码（[持续集成]())
2. 配置信息([配置管理]())
3. 运行环境([基础设施和环境管理]())
4. 数据([数据管理]())

**反馈流程**

完全自动化的方式尽可能的测试每一次变更

测试内容包括但不限于

* 创建可执行代码的流程必须是能奏效的。这用于验证源代码是否符合语法
* 软件的单元测试必须是成功的。这可以检查应用程序的行为是否与期望相同
* 软件应该满足一定的质量标准，比如测试覆盖率以及其他与技术相关的度量项
* 软件的功能验收测试必须是成功的。这可以检查应用是否满足业务验收条件，交付了所期望的业务价值
* 软件的非功能测试必须是成功的。这可以检查应用程序是否满足用户对性能、有效性、安全性等方面的要求
* 软件必须通过了探索性测试，并给客户以及部分用户做过演示。这些通常在一个手工测试环境上完成。此时，产品负责人可能认为软件功能还有缺失，我们自己也可能发现需要修复的缺陷，还要为其写自动化测试来避免回归测试

### 1.3.2. 反馈应该尽快发出

关键是自动化，主要通过部署流水线来实现，后面各章会详细介绍

### 1.3.3. 交付团队必须接收反馈，并依据它做出行动响应

没有响应，反馈何用？

### 1.3.4. 这个流程可以推广吗

很多思想来源于精益制造，目标是快速交付高质量的产品，聚焦于消除浪费，减少成本

这个思想已经被多个行业所证明，而且作者也经历过很多采用更持续交付的项目

## 1.4. 收效

### 1.4.1. 授权团队

让整个团队合作在一起

### 1.4.2. 较少错误

通过减少手工的重复任务，避免大部分错误

### 1.4.3. 缓解压力

让发布任务变得简单可控，免得每次发布都如临大敌

### 1.4.4. 部署的灵活性

随时找到以往的部署版本，意见部署任意版本

### 1.4.5. 多加练习，使其完美

目标是不管部署到什么环境，都使用相同的部署方法

## 1.5. 候选发布版本

**每次提交代码都产生一个可发布版本**

但是实际开发中，要想验证一个可发布版本，就要进行一次集成，通常这个过程难以控制，所以就会推迟，集成频率越低，越痛苦，但是越痛苦的事，越要频繁去做，要么会更痛苦

本书会通过持续集成这一实践来让集成变得无痛

## 1.6. 软件交付的原则

为了保证高质量的持续交付，下面的可以当做行为准则了

### 1.6.1. 为软件的发布创建一个可重复且可靠的过程

归根结底，软件的部署包括三件事

* 提供并管理软件所需要的运行环境，包括硬件配置，所依赖的软件，基础设施以及所需的外部服务
* 将应用程序的正确版本安装其上
* 配置应用程序，包括所需的任何数据和状态

### 1.6.2. 将几乎所有的事情自动化

能让机器去做的就别自己做了

### 1.6.3. 把所有的东西都纳入版本控制

使每个版本相关的信息都能很快找到

### 1.6.4. 提前并频繁的做让你感到痛苦的事

这是一条很有用的启发式原则

### 1.6.5. 内建质量

每个人都对质量负责，有问题立马解决

### 1.6.6. “DONE”意味着“已发布”

我们认为一个特性只有交到用户手中才算DONE，而不是开发完了就OK了

### 1.6.7. 交付过程是每个成员的责任

从相互指责扯皮到共同协作

### 1.6.8. 持续改进

戴明环（plan->do->check->act）

## 1.7. 小结

本书的目标是让发布过程变得无痛

# 2. 第二章 配置管理

## 2.1. 引言

> 定义: 配置管理是指一个过程, 通过该过程, 所有与项目相关的产物, 以及他们之间的关系, 都被唯一的定义, 存储, 检索和修改

## 2.2. 使用版本控制

### 2.2.1. 对所有内容进行版本控制

至少要将那些用于重新创建应用程序的安装文件和安装环境所必需的所有信息保存在版本控制库中，包括

* 代码
* 文档
* 工具
* 构建环境的信息

持续集成，自动化测试，一键式部署的前提都是所有与项目相关的内容都在版本控制库中

### 2.2.2. 频繁提交代码到主干

两个最佳实践

* 提交之前运行自动化测试
* 增量式引入变化，改一点提交一点

### 2.2.3. 使用意义明显的提交注释

包括下面三个部分

* 总结性描述
* 细节性描述
* 相关问题或者bug的链接

## 2.3. 依赖管理

### 2.3.1. 外部库文件管理

### 2.3.2. 组件管理

关于依赖管理更多的会在[第十三章 组件和依赖管理]()中进行讨论

## 2.4. 软件配置管理

### 2.4.1. 配置与灵活性

就像性能调优一样，没又遇到性能问题时不要过早优化，配置也是同样道理，除非真的需要，否则没必要增加复杂性

### 2.4.2. 配置的分类

我们可以在构建，部署，测试和发布过程中任何一个阶段引入配置

不建议在构建打包时引入配置，应该保证部署之前所有的包是一样的

### 2.4.3. 应用程序的配置管理

1. 获取配置信息

让所有应用程序通过一个中央服务系统（关系数据库，LDAP，Web服务等）得到他们所需的配置信息

ESCAPE工具

2. 为配置项建模

一个配置项取决于三个方面

* 应用程序
* 应用程序的版本
* 运行环境（开发，测试，生产）

3. 系统配置的测试

* 保证外部服务都开启
* 对与配置项相关的功能进行自动化的冒烟测试

### 2.4.4. 跨应用的配置管理

每个应用程序的配置管理都应该在项目启动时纳入一个议题

### 2.4.5. 管理配置信息的原则

* 确定注入配置的时机
* 配置项和配置值分开存储
* 总是自动化获取配置
* 每个人应该都能容易的获取当前应用当前版本在当前环境下的配置信息
* 命名简单易懂
* 确保配置信息修改的模块化，改一边不会影响另一边
* 不要重复定义配置项
* 最少化配置
* 避免过分设计
* 确保对配置操作也有测试

## 2.5. 环境管理

关键在于全自动的创建一套环境，使创建环境比修复受损环境要容易的多

为什么需要重现环境的能力

* 避免人员离职产生的知识遗失
* 修复时间往往大于重建环境的时间
* 可以保持各个环境的统一

需要考虑的环境配置信息如下

* 操作系统（版本，补丁级别和配置设置）
* 第三方包（版本，配置）
* 网络拓扑
* 所依赖的外部服务（版本，配置）
* 现有的数据及其他相关信息

为了符合我们的管理策略，评估第三方产品或服务时，应该考虑下面的问题

* 是否可以自动部署
* 是否可以对配置做版本控制
* 是否能适应我们的自动化部署策略

### 2.5.1. 环境管理工具

Puppet，CfEngine，虚拟化技术等

更多讨论在[第十一章 基础设施和环境管理]()

### 2.5.2. 变更过程管理

严格控制生产环境，未经组织内部正式的变更管理过程，任何人不得对其进行修改

## 2.6. 小结

配置管理是一切自动化的基础

# 3. 第三章 持续集成

## 3.1. 引言

持续集成的目标是让软件一直处于可工作的状态

## 3.2. 实现持续集成

### 3.2.1. 准备工作

1. 版本控制
2. 自动化构建
3. 团队共识

### 3.2.2. 一个基本的持续集成系统

开发人员使用持续集成服务的简单流程

1. 查看一下是否有构建正在运行，如果有的话，等它完事，如果它失败了，就和团队的其他人把他一起修复，然后再提交代码
2. 一旦构建完成且测试完全通过，就从版本控制库中将该版本的代码更新到自己的开发环境上
3. 在自己的开发机上执行构建脚本，运行测试，以确保在你机器上的所有代码都正常工作
4. 如果本地构建成功，你提交代码
5. 然后等待你这次提交的构建结果
6. 如果失败了，停下手中的活，修复问题，转到步骤3
7. 如果成功，庆祝一下，开始下个任务吧

## 3.3. 持续集成的前提条件

### 3.3.1. 频繁提交

### 3.3.2. 全面的自动话测试套件

单元测试，集成测试，验收测试

### 3.3.3. 保持较短的构建和测试过程

频繁的执行不能占据太长时间

### 3.3.4. 管理开发工作区

开发人员开始新任务的时候，应该总是从一个已知正确的状态开始

## 3.4. 使用持续集成软件

Jenkins，CruiseControl，Go，TeamCity等

## 3.5. 必不可少的实践

### 3.5.1. 构建失败之后不要提交新代码

### 3.5.2. 提交前在本地运行所有的提交测试，或者让持续集成服务器完成此事

### 3.5.3. 等提交测试通过之后再继续工作

### 3.5.4. 回家之前，构建必须处于成功状态

如果你不想第二天被同事骂的话

### 3.5.5. 时刻准备着回滚到前一个版本

按照持续继承的流程，前一个版本肯定是没有问题的

### 3.5.6. 在回滚之前规定一个修复时间

比如说10分钟没有修复问题，就回滚

### 3.5.7. 不要将失败的测试注释掉

要么测试错了，要么改出问题了，，要么测试可以删除了，酌情处理，而不是注释掉

### 3.5.8. 为自己的导致的问题负责

### 3.5.9. 测试驱动开发

## 3.6. 推荐的实践

我们任务下面的实践也是有用的

* 若违背架构原则，就让构建失败
* 若测试运行变慢，就让构建失败
* 若有编译警告或者代码风格问题，就让测试失败

## 3.8. 小结

持续集成是部署流水线的基石，即使只采用了持续集成，也会对开发流程带来极大的改善

# 5. 第五章 部署流水线解析

## 5.1. 引言

持续集成就能带来很大而效果了，但是持续集成主要关注的是开发团队，但是很多时间是浪费在测试和部署阶段上面的，我们需要一个端到端的方法来交付软件，最好能做到一键构建测试和部署

## 5.2. 什么是部署流水线

抽象来讲，部署流水线是指软件从版本库到用户手中这一过程的自动话表现形式

部署流水线主要包括四个阶段

* **提交阶段**，从技术上断言系统是可以工作，主要包括编译，单元测试和代码分析等
* **自动化验收测试阶段**，从功能和非功能两个角度断言系统是可以工作的，也说明该系统符合用户的需求规范
* *手工测试阶段**，用于断言系统是可用的，满足了它的系统要求，试图发现那些自动化测试没能发现的问题，并验证系统是否为用户提供了价值。这一阶段包括探索性测试，集成环境上的测试和用户验收测试（UAT）
* **发布阶段**，将软件交付给客户，既可能是以套装软件的形式，也可能是直接将其部署到生产环境或试运行环境

**一个基本的流水线**

![一个基本的流水线](https://ronnie.wang/images/deploy-pipeline.jpg)

## 5.3. 部署流水线的相关实践

### 5.3.1. 只生成一次二进制包

避免两次构建生成的包不一致的情况

> 记住，始终在已知可靠的基础上行进

### 5.3.2. 对不同环境采用统一的部署方式

将部署流程脚本和配置分离开来，所有的环境都使用一样的流程进行部署

### 5.3.3. 对部署进行冒烟测试

简单的看看应用是否启动成功，数据库，中间件是否已经启动即可

### 5.3.4. 向生产环境的副本进行部署

在与生产环境一样的环境中进行测试和持续集成

### 5.3.5. 每次变更都要立即在流水线中传递

### 5.3.6. 只要有环节失败，就停止整个流水线

失败了放下手头的活，赶紧修复这个问题，再做别的事

## 5.4. 提交阶段

一些提交阶段有用的度量标准

* 测试覆盖率
* 重复代码的数量
* 圈复杂度
* 输入耦合度，输出耦合度
* 编译警告的数量
* 代码风格

## 5.5. 自动化验收测试之门

只有单元测试不一定能保证程序可以运行，也不能保证实现了用户的需求

## 5.6. 后续的测试阶段

### 5.6.1. 手工测试

测试人员进行一些手工探索性测试，易用性测试和演示

### 5.6.2. 非功能测试

容量，安全性，SLA等，参见[第九章]()

## 5.7. 发布准备

缓解发布风险

* 让参与项目交付过程的人共同创建一个发布计划
* 通过尽可能多的自动化过程最小化为人错误发生的可能性，并从最容易出错的环节开始实现自动化
* 在类生产环境中经常做发布流程的演练，这样就可以对整个流程及其所使用的技术进行测试
* 如果事情没有按计划进行，要有撤销某次发布的能力
* 作为升级和撤销过程的一部分，制定配置迁移和数据迁移的策略

### 5.7.1. 自动部署与发布

将部署和发布自动化，这样就会频繁的部署，对部署的测试也就更多，也就不怕由部署和发布引入很大的问题了

### 5.7.2. 变更的撤销

如果部署引发了问题，要有回滚的策略，参见[第十章]()

### 5.7.3. 在成功的基础上构建

当产生一个候选版本的时候，我们可以确认所有通过部署流水线各个阶段的产物都是成功的

## 5.8. 实现一个部署流水线

### 5.8.1. 对价值流进行建模并创建简单的可工作框架

### 5.8.2. 构建和部署过程的自动化

### 5.8.3. 自动化单元测试和代码分析

### 5.8.4. 自动化验收测试

### 5.8.5. 部署流水线的演进

首先，并不需要一次实现整个流水线，而应该是增量式实现

其次，部署流水线是构建、部署、测试和发布应用程序整个流程中有效的，也是最重要的统计数据来源

最后，部署流水线也需要改进和维护

## 5.9. 度量

## 5.10. 小结

# 6. 第六章 构建与部署的脚本化

## 6.1. 引言

要实现

* 自动构建
* 自动部署

构建和部署系统一直要保持活力，这个系统不仅要从项目开始就开发，而且一直持续到产品到上线维护阶段，细心设计和维护它，像对待项目源代码一样，并定期使用，确保我们每次想用时，都能正确运行

## 6.2. 构建工具概览

### 6.2.1. Make

### 6.2.2. Ant

### 6.2.3. NAnt与MSBuild

### 6.2.4. Maven

惯例由于配置

三个问题

* 项目结构死板
* 扩展它要写代码（mojo插件）
* 默认情况下，自动更新，可能会导致某次构建无法重现

依赖和配置惯例参见[第十三章]()

### 6.2.5. Rake

### 6.2.6. Builder

### 6.2.7. Psake

## 6.3. 部署构建脚本化的原则与实践

### 6.3.1.为部署流水线的每个阶段创建脚本

刚开始可能只需要一个脚本，但是项目大了之后就要拆分，易于管理和维护

> 记住，部署脚本一定要放在版本控制库中

### 6.3.2. 使用恰当的技术部署应用程序

部署脚本应该能完成应用程序的安装和升级任务，在部署之前，他要能关闭当前运行的版本，而且既支持在当前数据库上升级，又能从头创建数据库

### 6.3.3. 使用同样的脚本向所有环境部署

将部署脚本和需要用到的配置信息分离开来，详情可参见[第二章]()

### 6.3.4. 使用操作系统自带的包管理工具

让自己的应用程序包的安装也想apache的安装一样

### 6.3.5. 确保部署流程是幂等的

确保每次部署都以已知状态良好的环境作为起点

很难实现，作为目标前进吧

### 6.3.6. 部署系统的增量式演进

逐步完善，每自动化一个过程，就是一个进步

## 6.4. 面向JVM的应用程序的项目结构

推荐使用Maven，Maven最大的贡献就是标准化了项目结构

* 任何生成的配置或元数据都应放在target下
* 单元测试与源代码对应
* 版本控制库应该忽略target目录
* 确保应用程序所有依赖都与应用程序的二进制包一起打包

## 6.5. 部署脚本化

> 核心原则：对测试和生产环境的修改只能由自动化过程执行

### 6.5.1. 多层的部署和测试

* 第一层（最底层)，硬件
* 第二层，操作系统，操作系统配置
* 第三层，中间件，中间件配置
* 第四层，应用/服务/组件，应用配置
 
保证下一层是准确的，可控的，稳定的配置，再开始上一层的部署

[这应该有一张图]()

### 6.5.2. 测试环境配置

简单的冒烟测试，证明我们的配置可以工作，可以从如下几方面入手

* 确认能从数据库拿到一条记录
* 确认能连上网站
* 断言消息代理中的已注册的消息集合是正确的
* 透过防火墙发送几次“ping”命令，证明线路是通的，且各服务器之间提供了一个循环分配负荷

关于基础设施管理，[第十一章]()有更详细的描述

## 6.6. 小贴士

### 6.6.1. 总是使用相对路径

如果不可避免要使用绝对路径，尽可能将这部分内容独立出来，不要让它影响构建系统的其他部分

### 6.6.2. 消除手工步骤

枯燥，极易出错，文档容易过时

当做第二次时要警觉，当你需要重复做第三次时，就把它自动化

### 6.6.3. 从二进制包到版本控制库的内建可追溯性

保证知道哪个二进制包是哪个版本库的哪个版本生成的

### 6.6.4. 不要把二进制包作为构建的一部分放到版本控制库中

### 6.6.5. “test”不应该让构建失败

不要一碰到错误就失败，最好都执行一遍流程，报告出所有错误，再失败

### 6.6.6. 用集成冒烟测试来限制应用程序

部署前简要测试一下机器是否正确，环境是否正确等

### 6.6.7. .NET小贴士

## 6.7. 小结

以迭代的方式来识别最令你痛苦的步骤，并将其自动化，沿着部署流水线，逐步完善自动化构建和部署能力。请时刻牢记最终目标，**即在开发、测试和生产环境中共享同一种部署机制**，但不要过早地纠结于工具的创建


# 7. 第七章 提交阶段

## 7.1. 引言

提交阶段的目标主要有两个

* 要么产生成功的可部署文件
* 要么快速反馈失败的原因，并阻止部署流水线之后的进程，这样可以保证错误不向后续步骤蔓延

提交阶段的开始和结束

当向版本库中进行一次提交时，`提交阶段`就开始了，提交阶段是部署流水线的开始

`提交阶段`的结果有两个

* 成功，产生可供后续测试和发布的二进制产物和可部署程序集
* 失败，得到失败报告

## 7.2. 提交阶段的原则和实践

为了建立高效的提交阶段，需要遵循下列原则和实践

### 7.2.1. 提供快速有用的反馈

如果有问题，尽早发现，尽早修改，这样解决错误所需的精力最少

### 7.2.2. 何时让构建成功

理论上将，提交阶段的失败来自于下面三种情况

* 编译错误
* 测试未通过
* 环境配置问题

### 7.2.3. 何时令提交阶段失败

但如果通过了，是真的通过了吗，是否可能有如下情况呢

* 编译警告很多
* 测试没有全部运行
* 代码质量并不高

这样还要让构建成功吗，这需要团队讨论，建立大家认可的标准，比如规定测试覆盖率，检测代码质量，控制编译警告数量等

但首要原则是，**如果构建失败，交付团队要立即停止手上的工作，把问题修复**

### 7.2.4. 精心对待提交阶段

对待提交阶段用到的脚本也要向对待程序的其他部分一样精心的**设计**和**维护**

这里有一些原则可供参考

* 将脚本做成模块化的
* 将那些经常使用但很少变化的与经常要修改的任务分离开来
* 将部署不同阶段用到的脚本写到不同的文件中
* 不要写出与具体环境相关的部署脚本，**将具体换进配置和构建脚本分离**

### 7.2.5. 让开发人员也拥有所有权

不要只让构建专家来管理构建过程，开发团队和运维团队都应参与进来，构建专家应该专注于下面的工作

* 构建过程的设计
* 构建知识的传授

### 7.2.6. 在超大项目团队中指定一个构建负责人

主要用于维护和巩固构建纪律

## 7.3. 提交阶段的结果

**制品库**

保存提交阶段输出结果的地方

一个候选发布版本在部署流水线中成功走向生产环境的步骤

1. 交付团队的某个人提交了一次更改
2. 持续集成服务器运行提交阶段
3. 成功结束后，**二进制包**，**所有报告**和**元数据**都被保存到`制品库`中
4. 持续集成服务器从`制品库`中获取提交阶段生产的二进制包，并将其部署到一个类生产测试环境中
5. 持续集成服务器使用提交阶段生成的二进制包执行验收测试
6. 成功完成后，该候选发布版本被标记为“已成功通过验收测试”
7. 测试人员拿到已通过验收测试的所有构建的列表，并通过单击一个按钮将其部署到手工测试环境中
8. 测试人员执行手工测试
9. 一旦手工测试也通过了，测试人员会更新这个候选发布版本的状态，指示它已经通过手工测试了
10. 持续集成服务器从`制品库`中拿到通过验收测试的最新候选版本，将其部署到生成测试环境
11. 对这个候选发布版本进行容量测试
12. 如果成功了，将这个候选版本的状态更新为“已通过容量测试”
13. 如果部署流水线中还有后续阶段的话，一直重复这种模式
14. 一旦这个候选发布版本通过了所有相关阶段，把它标记为“可以发布”，并且任何被授权的人都能将其发布，通常是由质量保证人员和运维人员共同批准
15. 一旦发布以后，将其标记为“已发布”

可以看到`制品库`处于一个核心的位置，串联起了各个流程

## 7.4. 提交测试阶段套件的原则与实践

关于单元测试的内容，可参考[另一篇文章](http://ronniewang.github.io/me/2016/03/14/unit-test.html)

### 7.4.1 避免用户界面

放到验收测试阶段处理

### 7.4.2. 使用依赖注入

### 7.4.3. 避免使用数据库

### 7.4.4. 在单元测试中避免异步

一个测试运行到异步点时，切分出来另一个测试

### 7.4.5. 使用测试替身

mock和stub

### 7.4.6. 最少化测试中的状态

虽然无法从根本上消除这种复杂性，持续关注“如何降低要构造测试环境的复杂性”是合理的

### 7.4.7. 时间的伪装

对于用到依赖系统时间的测试，改用stub

### 7.4.8. 蛮力

在测试套件运行过慢时，可以采用下面两个办法

* 拆分成多个测试套件，并行执行
* 将运行时间较长且不经常失败的测试放到验收测试阶段运行

这样可能导致的问题是知道问题的及时性有所降低

## 7.9. 小结

快速发现问题，快速做出反馈，快速解决问题，**快快快**

`提交阶段`虽然是`部署流水线`的起点，但是如果在你的流程中引入，仍然可以提供巨大的价值

# 10. 第十章 应用程序的部署与发布

## 10.1. 引言

## 10.2. 创建发布策略

创建发布策略的重要部分就是在项目计划阶段就与应用程序的所有干系人会面

制定部署策略需要考虑以下内容

* 每个环境的部署和发布都是有谁负责的
* 创建一个资产和配置管理策略
* 部署时所用技术的描述, 运维团队和开发团队应对其达成共识
* 实现部署流水线的计划
* 枚举所有环境, 包括用于验收测试, 容量测试, 集成测试, 用户验收测试的环境, 以及每个构建在这些环境中的移动过程
* 描述在测试和生成环境中部署时应该遵循的流程, 比如提交一个变更申请,以及申请授权等
* 对应用程序的监控需求, 包括用于通知运维团队关于应用程序相关状态的API或服务
* 讨论部署和运行时的配置方法如何管理, 以及他们与自动化部署流程是如何关联在一起的
* 描述应用程序如何与所有外部系统集成, 比如, 在哪个阶段进行集成?作为发布过程里的一份子, 如何对这种外部集成进行测试?一旦出现问题, 运维人员如何与供应商进行沟通?
* 如何记录日志详情, 以便运维人员能够确定应用程序的状态, 识别出错原因
* 制定灾难恢复计划, 以便在灾难发送之后, 可以恢复应用程序的状态
* 对软件的服务级别达成一致, 比如, 应用程序是否有像故障转移以及其他高可用策略等方面的需求
* 生成环境的数量大小及容量计划: 应用程序会创建多少数据?需要多少个日志文件或数据库?需要多少带宽或磁盘空间?客户对响应延迟的容忍度是什么?
* 制定一个归档策略, 以便不必为了审计或技术支持而保留生产数据
* 如何对生产环境进行首次部署
* 如何修复生产环境出现的缺陷,并为其打补丁
* 如何升级生成环境的应用程序以及迁移数据
* 如何做应用程序的生产服务和技术支持

### 10.2.1. 发布计划

* 第一次部署应用程序时所需的步骤
* 作为部署过程的一部分，如何对应用程序以及他所使用的服务进行冒烟测试
* 如果部署出现问题，需要哪些步骤来撤销部署
* 对应用程序的状态进行备份和恢复的步骤是什么
* 在不破坏应用程序状态的前提下，升级应用程序所需要的步骤是什么
* 如果发布失败，重新启动或重新部署应用程序的步骤是什么
* 日志文件放在哪里，以及它包括什么样的信息描述
* 如何对应用程序进行监控
* 作为发布的一部分，对必要的数据进行迁移的步骤有哪些
* 前一次部署问题的记录以及它们的解决方案是什么

### 10.2.2. 发布产品

对商业软件来说，还有如下考虑

* 收费模式
* 使用许可策略
* 所用第三方技术的版权问题
* 打包
* 市场活动所需要的材料
* 产品文档
* 安装包
* 销售和售后支持团队的准备

## 10.3. 应用程序的部署和晋级

### 10.3.1. 首次部署

首次部署一般是在首个迭代结束时，我们认为，这个阶段的只要目标是让部署流水线的前几个阶段可以运行，并能够展示一些成果

首个迭代结束时，应该有以下内容

* 部署流水线的提交阶段
* 一个用于部署的类生产环境
* 通过一个自动化得过程获取在提交阶段生成的二进制包，并将其部署到这个类生产环境中
* 一个简单的冒烟测试，证明本次部署是正确的，并且应用程序正在运行

一般来说，类生产环境有一下特点

* 操作系统与生成环境一致
* 其中安装的软件应该与生产环境一致，尤其不能在其上安装开发工具
* 参见11章的描述，用于管理生产环境相同的方式对这种环境进行管理
* 对于客户自行安装的软件，UAT环境应该基于客户硬件环境的统计结果，具有一定的代表性，至少要基于别人做过的真实统计

### 10.3.2. 对发布过程进行建模并让构建晋级

使应用程序从一个阶段可以通过部署流水线晋级到下一个阶段

### 10.3.3. 配置的晋级

### 10.3.4. 联合环境

几个程序共享一个环境的情况，可能引入两种复杂性

* 保证不同程序的环境配置不会冲突
* 管理好各个程序之间的依赖关系（如果他们之间有依赖的话）

### 10.3.5. 部署到试运行环境

自动化，预热，冒烟测试

## 10.4. 部署回滚和零停机发布

快速回滚，避免半夜加班在生产环境上进行调试

首先明确，回滚有两个难点

* 如果发布会修改数据，回滚会比较麻烦
* 如果与其他系统有集成，也比较麻烦

制定回滚计划之前，记住两个通用原则

* 发布前，确保生产系统的状态已经备份（数据库和文件系统）
* 发布前，练习一下回滚计划，确保可以正常工作

### 10.4.1. 通过重新部署原有的正常版本进行回滚

优点

* 在没有自动回滚流程，但有自动部署流程的情况下，这样风险较低
* 由于执行回滚的频率要低于执行部署的频率，所以重新部署更不容易出错

缺点

* 部署时，系统无法提供服务，导致有停机时间
* 由于覆盖了新版本，导致是去了寻找问题的最佳机会
* 如果新版本运行时产生了数据，回滚到旧版本会使这些数据丢失

### 10.4.2. 零停机发布

也叫“热部署”，在不影响服务的情况下实现升级和回滚

关键在于发布流程中各部分的解耦，尽量是他们独立发生，尤其是应用程序依赖的共享资源（数据库，静态资源等）被放到了适当的位置

### 10.4.3. 蓝绿部署

准备两套环境，一套叫“蓝环境”，一套叫“绿环境”

绿环境是当前生产环境，蓝环境是新版本的生产环境，部署新版本后，现在蓝环境上预热一下，没有问题后，直接修改路由，将用户引导到蓝环境即可，如果发现问题，再切回绿环境即可，还可在蓝环境上调试，寻找问题

这种方式的一个问题是小心管理数据，如何将绿环境的数据转移到蓝环境

有两个方法

* 在切换之前，将应用程序变成只读状态，然后复制绿环境数据库到蓝环境，然后在把用户切换到蓝环境
  * 如果一切正常，把应用程序变回读写状态
  * 否则，如果问题发生在切成读写状态之前，则什么都不用做；如果已经写入了一些数据，就需要想个办法将新纪录迁回绿环境，也可以让新版本将数据同时发向两个数据库
* 重新设计应用程序，以便让迁移数据与升级流程独立，参见12章

如果只有一套环境，也可以实现蓝绿部署，只要保证每个应用程序副本都有自己独立的资源（文件目录，端口，数据库等）即可

### 10.4.4. 金丝雀发布

先迁过去一小批用户，主键增加负载，如果发现问题，可以快速回滚

## 10.5. 紧急修复

> 记住: 任何情况下, 不能破坏流程

如果紧急恢复之后直接上到了生产环境, 就会产生一个未受控版本, 这会导致两个问题

* 本次修复未经过测试, 不能确定是否真的修复了问题, 也无法确定是否引入了回归问题
* 本次修改未记录在案, 使环境处于一种未知状态

有时候事情并不是那么紧急, 还有时候回滚比修复要更好

## 10.6. 持续部署

一切都自动化, 提交之后, 自动化部署到生产环境, 这要求自动化测试异常强大, 单元测试, 组件测试, 验收测试, 容量测试

终极目标, 逐步实现, 按下不表, 回头再看

## 10.7. 部署贴士和窍门

* 真正执行部署操作的人应该参与部署过程的创建，项目开始时，让开发人员和部署人员都知道要做什么
* 记录部署活动，特别是没有完全自动化的时候，人的记忆不靠谱
* 不要删除旧文件
* 新旧版本放在不同的文件夹下
* 部署应该是所有人都会的活动
* 服务器应用程序不应该有GUI，免除非要通过登录界面才能重启服务的尴尬
* 为新部署留预热期，“金丝雀”发布
* 快速失败，部署脚本也要有冒烟测试
* 不要直接对生产环境进行任何修改

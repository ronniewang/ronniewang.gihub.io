[《Effective Java》](effective-java-catalog.html)

## 13 使类和成员的可访问性最小化

* 尽可能地使每个类和成员都不被外界访问
* 实例域绝不能是公有的
* 要保证公有静态 final 域所引用的对象都是不可变的

## 14 在公有类中使用访问方法而非公有域

## 15 使可变性最小化

* 使类成为不可变类
	* 不要提供任何会修改对象状态的方法
	* 保证类不会被扩展
	* 使所有的域都是 final 的
	* 使所有域都是私有的
	* 确保对于任何可变组件的互斥访问（如果类具有指向可变对象的域，则必须保证该类的客户端无法获得指向这些对象的引用）
* 不可变对象的好处
	* 自带线程安全属性
	* 可以随意共享不可变对象
	* 为其他对象提供了大量的构件，因为维护不可变对象更加容易
* 唯一的缺点
	* 每个不同的值都需要一个单独的对象，对象过大，耗资源
	* 解决方案
		* 一、猜测一下会经常用到的多步骤操作，然后将它们作为基本类型提供（没太看懂，希望能找到个例子）
		* 二、提供配套的可变类（StringBuilder 之于 String，BitSet 之于 BitInteger）
* 如果类无法被做成不可变的，则尽量限制他的可变性，除非有理由使域变为非 final 的，否则，都应该是 final 的



## 16 复合优于继承

* 完全可以控制继承关系，或者两个类型确实是 is-a 的关系，才考虑用继承
* 父类会变，带来很多问题，破坏了封装性，还可能将父类 API 的缺陷传递到子类
* 装饰器模式与代理模式的区别？？？


## 17

## 18 接口由于抽象类

* 接口的优势
  * 现有的类可以很容易被更新，来实现一个新的接口
  * 接口是定义 [mixin](what-is-mixin.html) 的理想选择
  * 接口允许我们构造非层次结构的类型框架
* 通过对导出的接口都提供一个抽象的骨架实现类，把接口和抽象类的有点结合起来
* 可以通过在类内部包含多个实现不同接口的类实例来模拟多重继承
* 当演变的容易性比灵活性和功能性更重要的时候，可以考虑使用抽象类而不是接口

## 19 接口只用于定义类型

* 一个反面实例：用接口导出常量
* 应该用枚举或者不可实例化的工具类来实现

## 20 类层次优于标签类

* 一个 Figure 类既包含矩形的域，又包含圆形的域，通过标签进行区分
* 可以拆成一个抽象类，加两个子类的形式
	* Rectangle extends Figure
	* Circle extends Figure

## 21 用函数对象表示策略

* 就是将纯函数包装起来，没有域
* 适合用单例模式缓存起来
* 一般通过定义策略接口，实现类来实现不同的策略

## 22  优先考虑静态成员类

* 嵌套类
	* 静态成员类
   * 非静态成员类
	* 匿名类
	* 局部类
* 只有静态成员类的实例可以在外围类的实例之外单独存在
* 非静态成员类实例保存指向外围类的引用，耗费时间和空间

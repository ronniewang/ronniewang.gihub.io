[《Effective Java》](effective-java.html)

# 通用程序设计

## 45 将局部变量的作用域最小化46 for-each 循环优先于传统的 for 循环

* 隐藏迭代器或者索引变量，避免了混乱和出错的可能
* 任何实现 Iterable 接口的对象都可以使用 for-each 循环
* 无法使用的情形
  * 需要删除元素
  * 替换特定位置的元素
  * 平行迭代，并行地遍历多个集合
* 一个错误的小例子

```java
for (Iterator<Suit> i = suits.iterator(); i.hasNext(); )
    for (Iterator<Rank> j = ranks.iterator(); j.hasNext(); )
        deck.add(new Card(i.next(), j.next()));
```

## 47 了解和使用类库

* 好处
  * 通过使用标准类库，可以充分利用这些编写标准类库的专家的知识，以及在你之前其他人的使用经验
  * 节省时间
  * 类库性能往往会随着不断的改进越来越好
  * 使代码融入主流，更能被其他人重用
* 经常关注常用类库的更新
* 在需要实现一个功能的时候先查一查有没有相应的类库

## 48 如果需要精确的答案，请避免使用 float 和 double

* int 或 long
* BigDecimal

## 49 基本类型优于装箱类型

* 三个主要区别
  * == 表现不一样
  * 装箱类型有 null 值
  * 基本类型更省时间和空间
* 装箱类型的使用场景
  * 作为集合元素、键和值
  * 在参数化类型中使用
  * 反射调用方法

## 50 如果其他类型更合适，则尽量避免使用字符串

* 字符串不适合代替其他的值类型
* 字符串不适合替代枚举
* 字符串不适合替代聚集类型
  * String compoundKey = className + "#" + i.next();
* 字符串也不适合代替能力表（翻译好像不是很准确）

## 51 当心字符串连接的性能

* 加号的时间复杂度是 n^2
* 使用 StringBuilder 代替加号

## 52 通过接口引用对象

* 如果依赖于特定实现类的特殊属性，就要在声明变量的地方建立相关文档，防止替换实现类的时候没有考虑到
* 如果没有接口，使用基类引用对象

## 53 接口由于反射机制

* 反射的缺点
  * 丧失了编译时类型检查的好处
  * 代码繁多
  * 有性能损失
* 反射应该只是设计时被用到，运行时不应该通过反射方式访问对象
* 当然，反射也是很强大的机制，必须要用的时候尽管使用，例如使用编译时还不存在的类

## 54 谨慎的使用本地方法

* 本地方法通常的三种用途
  * 提供了“访问特定于平台的机制”的能力，如注册表和文件锁
  * 访问遗留代码库
  * 利用本地需要提高性能，随着虚拟机的发展，现在基本不需要了
* 坏处
  * 本地语言不安全
  * 不可移植
  * 更难调试
  * 调用有额外开销
  * 模板代码多，单调乏味

## 55 谨慎地进行优化

* 不要因为性能牺牲合理的结构，要努力编写好的程序而不是快的程序
* 设计 API、线路层协议和永久数据格式的时候，一定要考虑性能的因素
* 在优化时，优先考虑所选算法的复杂度

## 56 遵守普遍接受的命名惯例

* 没啥好说的，基本都知道

---
layout: default
title: Zookeeper的leader选举过程
category: tech
description: Zookeeper的leader选举过程分为两种, 启动期选举和运行期选举
---

### 1. Zookeeper启动时的Leader选举过程

Leader选举需要在集群环境下进行, 所以单机Zookeeper是不需要进行Leader选举的, 我们假设集群中有三台服务器, 在服务器启动时, 每台机器都在寻找Leader

在选举一开始的时候, 每个人都很骄傲的投给自己一票, 并将投票信息发给其他机器, 投票上包含两个信息, 自己的Server ID和这次投票的事务ID(也叫ZXID), 比如对于Server1, 我们表示为`(1, 0)`

在接收到其他服务器的投票之后, 服务器首先对选票进行校验(如何校验???), 校验通过后, 接下来处理选票

处理选票的过程我们可以这么理解, 选举的目的就是要形成一个统一的结果, 而且, 这个结果有两种情况

* 要么是我自己发出的投票
* 要么是我接收到的其他服务器的投票

所以, 为了达成这样一个统一的结果, 服务器就需要更新自己的选票, 然后重新投票, 以达成统一的结果

更新的逻辑的这样的

服务器首先判断选票的ZXID, 将ZXID大的作为自己的选票, 如果ZXID相同, 判断ServerID, 将ServerID大的作为自己的选票, 如果都相同, 则自己的选票还是原来的那张
 
更新选票之后, 重新将选票发出

在每一次投票之后, 服务器都会进行统计, 当有超过半数的选票选择同一台服务器时, 这个服务器就被认为是Leader, 拿我们这个三台机器的集群来说

为了简化描述, 这里我们只考虑2台服务器的交互即可, 因为2台即满足过半的需求, 3台之间的交互也是同理的
1. Server1发出投票(1,0)
2. Server2发出投票(2,0)
3. Server2收到(1,0), 与自己的对比, 先比较ZXID, 发现一样, 再比较ServerID, 自己的比较大, 所以选票不变, 继续发出
4. Server1收到(2,0), 与自己的对比, 先比较ZXID, 发现一样, 再比较ServerID, 发现对方的比较大, 将自己的选票改为(2,0), 继续发出
5. Server1和Server2收到第二轮的投票之后, 继续进行比较和更新, 发现两台服务器都投了(2,0), 两台服务器已经过半数, 所以, 此时Server2作为Leader

当Leader选定之后, 每个服务器就更新自己的状态, Leader将自己更新为LEADING, Follower将自己更新为FOLLOWING, 至此, 选举结束